import { OnInit, Component } from '@angular/core';
import * as Diff2Html from 'diff2html';
import * as Diff from 'diff'

@Component({
  templateUrl: './missing-translation-handler.component.html',
})
export class MissingTranslationHandlerComponent implements OnInit {

  rightSidebarLinks: any = [{ "id": "missing-translation-handler", "title": "missing-translation-handler", "subLink": null }, { "id": "missing-translation-handler", "title": "missing-translation-handler", "subLink": null }];
  outputHtml: string;

  ngOnInit() {
    this.init();
  }

  init() {
    let ngxContent: any = "import { TestBed } from \"@angular\/core\/testing\";\r\nimport { Observable, of } from \"rxjs\";\r\nimport { MissingTranslationHandler, MissingTranslationHandlerParams, TranslateLoader, TranslateModule, TranslateService } from \"..\/src\/public_api\";\r\n\r\nlet translations: any = { \"TEST\": \"This is a test\" };\r\nlet fakeTranslation: any = { \"NOT_USED\": \"not used\" };\r\n\r\nclass FakeLoader implements TranslateLoader {\r\n  getTranslation(lang: string): Observable<any> {\r\n    if (lang === 'fake') {\r\n      return of(fakeTranslation);\r\n    }\r\n\r\n    return of(translations);\r\n  }\r\n}\r\n\r\ndescribe('MissingTranslationHandler', () => {\r\n  let translate: TranslateService;\r\n  let missingTranslationHandler: MissingTranslationHandler;\r\n\r\n  class Missing implements MissingTranslationHandler {\r\n    handle(params: MissingTranslationHandlerParams) {\r\n      return \"handled\";\r\n    }\r\n  }\r\n\r\n  class MissingObs implements MissingTranslationHandler {\r\n    handle(params: MissingTranslationHandlerParams): Observable<any> {\r\n      return of(`handled: ${params.key}`);\r\n    }\r\n  }\r\n\r\n  let prepare = ((handlerClass: Function, defaultLang: boolean = true) => {\r\n    TestBed.configureTestingModule({\r\n      imports: [\r\n        TranslateModule.forRoot({\r\n          loader: { provide: TranslateLoader, useClass: FakeLoader },\r\n          useDefaultLang: defaultLang\r\n        })\r\n      ],\r\n      providers: [\r\n        { provide: MissingTranslationHandler, useClass: handlerClass }\r\n      ]\r\n    });\r\n    translate = TestBed.get(TranslateService);\r\n    missingTranslationHandler = TestBed.get(MissingTranslationHandler);\r\n  });\r\n\r\n  afterEach(() => {\r\n    translate = undefined;\r\n    translations = { \"TEST\": \"This is a test\" };\r\n    missingTranslationHandler = undefined;\r\n  });\r\n\r\n  it('should use the MissingTranslationHandler when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should propagate interpolation params when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    let interpolateParams = { some: 'params' };\r\n\r\n    translate.get('nonExistingKey', interpolateParams).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ interpolateParams: interpolateParams }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should propagate TranslationService params when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    let interpolateParams = { some: 'params' };\r\n\r\n    translate.get('nonExistingKey', interpolateParams).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ translateService: translate }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should return the key when using MissingTranslationHandler & the handler returns nothing', () => {\r\n    class MissingUndef implements MissingTranslationHandler {\r\n      handle(params: MissingTranslationHandlerParams) {\r\n      }\r\n    }\r\n\r\n    prepare(MissingUndef);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      expect(res).toEqual('nonExistingKey');\r\n    });\r\n  });\r\n\r\n  it('should not call the MissingTranslationHandler when the key exists', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get('TEST').subscribe(() => {\r\n      expect(missingTranslationHandler.handle).not.toHaveBeenCalled();\r\n    });\r\n  });\r\n\r\n  it('should use the MissingTranslationHandler when the key does not exist & we use instant translation', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant('nonExistingKey')).toEqual('handled');\r\n    expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n  });\r\n\r\n  it('should wait for the MissingTranslationHandler when it returns an observable & we use get', () => {\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      expect(res).toEqual('handled: nonExistingKey');\r\n    });\r\n  });\r\n\r\n  it('should wait for the MissingTranslationHandler when it returns an observable & we use get with an array', () => {\r\n    let tr = {\r\n      nonExistingKey1: 'handled: nonExistingKey1',\r\n      nonExistingKey2: 'handled: nonExistingKey2',\r\n      nonExistingKey3: 'handled: nonExistingKey3'\r\n    };\r\n\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get(Object.keys(tr)).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledTimes(3);\r\n      expect(res).toEqual(tr as any);\r\n    });\r\n  });\r\n\r\n  it('should not wait for the MissingTranslationHandler when it returns an observable & we use instant', () => {\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant('nonExistingKey')).toEqual('nonExistingKey');\r\n  });\r\n\r\n  it('should not wait for the MissingTranslationHandler when it returns an observable & we use instant with an array', () => {\r\n    let tr = {\r\n      nonExistingKey1: 'handled: nonExistingKey1',\r\n      nonExistingKey2: 'handled: nonExistingKey2',\r\n      nonExistingKey3: 'handled: nonExistingKey3'\r\n    };\r\n\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant(Object.keys(tr))).toEqual({\r\n      nonExistingKey1: 'nonExistingKey1',\r\n      nonExistingKey2: 'nonExistingKey2',\r\n      nonExistingKey3: 'nonExistingKey3'\r\n    } as any);\r\n  });\r\n\r\n  it('should not return default translation, but missing handler', () => {\r\n    prepare(Missing, false);\r\n    translate.use('en');\r\n    translate.use('fake');\r\n\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('TEST').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'TEST' }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should return default translation', () => {\r\n    prepare(Missing, true);\r\n    translate.use('en');\r\n    translate.use('fake');\r\n\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('TEST').subscribe((res: string) => {\r\n      expect(res).toEqual('This is a test');\r\n    });\r\n  });\r\n});"
    let rxwebContent: any = "import { TestBed, fakeAsync, async } from \"@angular\/core\/testing\";\r\nimport { Observable, of } from \"rxjs\";\r\nimport { MissingTranslationHandler, MissingTranslationHandlerParams, TranslateLoader, } from \"@ngx-translate\/core\";\r\nimport { TranslateModule, TranslateService } from '@rxweb\/ngx-translate-extension'\r\nimport { RxTranslateModule } from \"@rxweb\/translate\"\r\n\r\nlet translations: any = { \"TEST\": \"This is a test\" };\r\nlet fakeTranslation: any = { \"NOT_USED\": \"not used\" };\r\n\r\nclass FakeLoader implements TranslateLoader {\r\n  getTranslation(lang: string): Observable<any> {\r\n    if (lang === 'fake') {\r\n      return of(fakeTranslation);\r\n    }\r\n\r\n    return of(translations);\r\n  }\r\n}\r\n\r\ndescribe('MissingTranslationHandler', () => {\r\n  let translate: TranslateService;\r\n  let missingTranslationHandler: MissingTranslationHandler;\r\n\r\n  class Missing implements MissingTranslationHandler {\r\n    handle(params: MissingTranslationHandlerParams) {\r\n      return \"handled\";\r\n    }\r\n  }\r\n\r\n  class MissingObs implements MissingTranslationHandler {\r\n    handle(params: MissingTranslationHandlerParams): Observable<any> {\r\n      return of(`handled: ${params.key}`);\r\n    }\r\n  }\r\n\r\n  let prepare = ((handlerClass: Function, defaultLang: boolean = true) => {\r\n    TestBed.configureTestingModule({\r\n      imports: [\r\n        TranslateModule.forRoot({\r\n          useDefaultLang: defaultLang,\r\n          loader: FakeLoader\r\n        }),\r\n        RxTranslateModule.forRoot({\r\n          isTest: true,\r\n          forNgxTranslate: true,\r\n          cacheLanguageWiseObject: true,\r\n        })\r\n      ],\r\n      providers: [\r\n        { provide: MissingTranslationHandler, useClass: handlerClass }\r\n      ]\r\n    });\r\n    translate = TestBed.get(TranslateService);\r\n    missingTranslationHandler = TestBed.get(MissingTranslationHandler);\r\n    console.log(missingTranslationHandler);\r\n  });\r\n\r\n  afterEach(() => {\r\n    translate = undefined;\r\n    translations = { \"TEST\": \"This is a test\" };\r\n    missingTranslationHandler = undefined;\r\n  });\r\n\r\n  it('should use the MissingTranslationHandler when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should propagate interpolation params when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    let interpolateParams = { some: 'params' };\r\n\r\n    translate.get('nonExistingKey', interpolateParams).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ interpolateParams: interpolateParams }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should propagate TranslationService params when the key does not exist', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    let interpolateParams = { some: 'params' };\r\n\r\n    translate.get('nonExistingKey', interpolateParams).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ translateService: translate }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should return the key when using MissingTranslationHandler & the handler returns nothing', () => {\r\n    class MissingUndef implements MissingTranslationHandler {\r\n      handle(params: MissingTranslationHandlerParams) {\r\n      }\r\n    }\r\n    prepare(MissingUndef);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      expect(res).toEqual('nonExistingKey');\r\n    });\r\n  });\r\n\r\n  it('should not call the MissingTranslationHandler when the key exists', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('TEST').subscribe((t) => {\r\n      expect(missingTranslationHandler.handle).not.toHaveBeenCalled();\r\n    });\r\n  });\r\n\r\n  it('should use the MissingTranslationHandler when the key does not exist & we use instant translation', () => {\r\n    prepare(Missing);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant('nonExistingKey')).toEqual('handled');\r\n    expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n  });\r\n\r\n  it('should wait for the MissingTranslationHandler when it returns an observable & we use get', () => {\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get('nonExistingKey').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'nonExistingKey' }));\r\n      expect(res).toEqual('handled: nonExistingKey');\r\n    });\r\n  });\r\n\r\n  it('should wait for the MissingTranslationHandler when it returns an observable & we use get with an array', () => {\r\n    let tr = {\r\n      nonExistingKey1: 'handled: nonExistingKey1',\r\n      nonExistingKey2: 'handled: nonExistingKey2',\r\n      nonExistingKey3: 'handled: nonExistingKey3'\r\n    };\r\n\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    translate.get(Object.keys(tr)).subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledTimes(3);\r\n      expect(res).toEqual(tr as any);\r\n    });\r\n  });\r\n\r\n  it('should not wait for the MissingTranslationHandler when it returns an observable & we use instant', () => {\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant('nonExistingKey')).toEqual('nonExistingKey');\r\n  });\r\n\r\n  it('should not wait for the MissingTranslationHandler when it returns an observable & we use instant with an array', () => {\r\n    let tr = {\r\n      nonExistingKey1: 'handled: nonExistingKey1',\r\n      nonExistingKey2: 'handled: nonExistingKey2',\r\n      nonExistingKey3: 'handled: nonExistingKey3'\r\n    };\r\n\r\n    prepare(MissingObs);\r\n    translate.use('en');\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n\r\n    expect(translate.instant(Object.keys(tr))).toEqual({\r\n      nonExistingKey1: 'nonExistingKey1',\r\n      nonExistingKey2: 'nonExistingKey2',\r\n      nonExistingKey3: 'nonExistingKey3'\r\n    } as any);\r\n  });\r\n\r\n  it('should not return default translation, but missing handler', () => {\r\n    prepare(Missing, false);\r\n    translate.use('en');\r\n    translate.use('fake');\r\n\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('TEST').subscribe((res: string) => {\r\n      expect(missingTranslationHandler.handle).toHaveBeenCalledWith(jasmine.objectContaining({ key: 'TEST' }));\r\n      \/\/test that the instance of the last called argument is string\r\n      expect(res).toEqual('handled');\r\n    });\r\n  });\r\n\r\n  it('should return default translation', () => {\r\n    prepare(Missing, true);\r\n    translate.use('en');\r\n    \/\/translate.use('fake');\r\n\r\n    spyOn(missingTranslationHandler, 'handle').and.callThrough();\r\n    translate.get('TEST').subscribe((res: string) => {\r\n\r\n      expect(res).toEqual('This is a test');\r\n    });\r\n  });\r\n});\r\n"

    var diff = Diff.createTwoFilesPatch("ngx-translate/missing-translation-handler.spec.ts", "rxweb/missing-translation-handler.spec.ts", ngxContent, rxwebContent);

    let outputHtml = Diff2Html.html(diff, {
      drawFileList: true, matching: 'lines', outputFormat: 'side-by-side'
    });
    this.outputHtml = outputHtml;
  }
}